<!DOCTYPE html>
<html lang="en">
<head>
    <title>Immersive Autochromes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #container {
            width: 100%;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
        }

        #VRButton {
            z-index: 99999 !important;
        }

        .button-container {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column; /* Change to 'row' for horizontal layout */
            gap: 10px; /* Space between buttons */
        }

        .button {
            padding: 10px 15px;
            background-color: rgba(255, 255, 255, 0.7);
            border: none;
            cursor: pointer;
            font-size: 16px;
        }
    </style>
    <script type="importmap">
        {
           "imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
        }

    </script>
</head>
<body>
<div id="container"></div>

<div class="button-container">
    <!--  <button id="prevButton" class="button">Previous</button>-->
    <button id="playButton" class="button">Play</button>
    <button id="stopButton" class="button" disabled>Stop</button>
    <button id="nextButton" class="button">Next</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import {VRButton} from 'three/addons/webxr/VRButton.js';
    // import { XR_BUTTONS } from 'gamepad-wrapper';
    import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
    import GUI from 'three/addons/libs/lil-gui.module.min.js';
    import { initSequencePlayer } from './js/sequencePlayer.js';

    const scene = new THREE.Scene();
    const data = JSON.parse('{"Height": 745, "Width": 960, "hFov": 0.9272952180016122, "vFov": 0.7412849108138079}');
    const maxFov = 90;

    const user = new THREE.Group();
    const camera = new THREE.PerspectiveCamera(maxFov, window.innerWidth / window.innerHeight, 0.1, 100);
    user.add(camera);
    scene.add(user);

    const renderer = new THREE.WebGLRenderer({
        antialias: false, // Disable antialiasing for better performance
        powerPreference: "high-performance",
        stencil: false,
        depth: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x808080);
    renderer.xr.enabled = true;
    
    // Optimize for performance
    renderer.setPixelRatio(1); // Force 1:1 pixel ratio for VR performance
    renderer.shadowMap.enabled = false;
    
    // VR-specific optimizations - the big wins
    renderer.xr.setFramebufferScaleFactor(0.7); // Lower XR render resolution (the big win)
    if (renderer.xr.setFoveation) renderer.xr.setFoveation(1);
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.sortObjects = false; // if you have 1 mesh, sorting is wasted work

    const vrButton = VRButton.createButton(renderer);
    document.body.appendChild(vrButton);
    document.getElementById('container').appendChild(renderer.domElement);

    let cameraZOffset = 0;
    let cameraZMaxOffset = 0.025;
    let direction = 1;
    
    // On-demand rendering system
    let needsRender = true;
    function requestRender() { needsRender = true; }


    const loader = new GLTFLoader();
    // =============================
    // GUI for point size and sampling
    // =============================
    const guiState = {
        pointSize: 2.0,
        samplePercent: 100
    };
    const gui = new GUI();
    gui.add(guiState, 'pointSize', 0.1, 10.0, 0.1).name('Point size').onChange(() => {
        applyPointSettingsToRoot(currentModel);
        requestRender();
    });
    gui.add(guiState, 'samplePercent', 1, 100, 1).name('Sample %').onChange(() => {
        applyPointSettingsToRoot(currentModel);
        requestRender();
    });

    function configurePointsMaterial(material) {
        if (!material || material.userData.__samplingPatched) {
            // Still update point size and uniforms if available
            if (material) {
                material.size = guiState.pointSize;
                if (material.userData && material.userData.__uniforms && material.userData.__uniforms.uSampleFraction) {
                    material.userData.__uniforms.uSampleFraction.value = Math.max(0.0, Math.min(1.0, guiState.samplePercent / 100));
                }
            }
            return;
        }

        material.size = guiState.pointSize;
        material.onBeforeCompile = (shader) => {
            material.userData.__uniforms = shader.uniforms;
            shader.uniforms.uSampleFraction = { value: Math.max(0.0, Math.min(1.0, guiState.samplePercent / 100)) };

            // Pass position to fragment
            shader.vertexShader = `varying vec3 vPos;\n` + shader.vertexShader;
            shader.vertexShader = shader.vertexShader.replace('void main() {', 'void main() {\n    vPos = position;');

            // Discard a fraction of points deterministically based on position
            const inject = `\nuniform float uSampleFraction;\nvarying vec3 vPos;\nfloat hash31(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898,78.233,37.719))) * 43758.5453);\n}\n`;
            shader.fragmentShader = inject + shader.fragmentShader;
            shader.fragmentShader = shader.fragmentShader.replace('void main() {', 'void main() {\n    if (hash31(vPos) > uSampleFraction) { discard; }');
        };
        material.userData.__samplingPatched = true;
        material.needsUpdate = true;
    }

    function applyPointSettingsToRoot(root) {
        if (!root) return;
        root.traverse((node) => {
            if (node && node.isPoints && node.material) {
                configurePointsMaterial(node.material);
                node.material.size = guiState.pointSize;
                if (node.material.userData && node.material.userData.__uniforms && node.material.userData.__uniforms.uSampleFraction) {
                    node.material.userData.__uniforms.uSampleFraction.value = Math.max(0.0, Math.min(1.0, guiState.samplePercent / 100));
                }
            }
        });
    }

    
    // Create a shared material once for reuse - optimized for VR
    const sharedMaterial = new THREE.MeshBasicMaterial({
        vertexColors: true,
        transparent: false,
        opacity: 1.0,
        flatShading: true,
        side: THREE.FrontSide, // Only render front faces for VR performance
        depthWrite: true,
        depthTest: true
    });
    
    let models = [
        // 'models/cacdoha_000122_access_crop.glb',
        'models/test5.glb',
        'models/test7.glb',
        
        'models/cacdoha_000089_access_crop.glb',

        /*
        'models/cacdoha_000123_access_crop.glb',
        'models/cacdoha_000140_access_crop.glb',
        'models/cacdoha_000110_access_crop.glb',
        'models/cacdoha_000345_access_crop.glb',
        'models/cacdoha_000412_access_crop.glb',
        'models/cacdoha_000422_access_crop.glb',
        'models/cacdoha_000457_access_crop.glb',
        'models/cacdoha_000490_access_crop.glb',
        'models/cacdoha_000491_access_crop.glb',
        'models/cacdoha_000152_access_crop.glb',
        'models/cacdoha_000154_access_crop.glb',
        'models/cacdoha_000161_access_crop.glb',
        'models/cacdoha_000321_access_crop.glb',
        'models/cacdoha_000089_access_crop.glb',
        'models/cacdoha_000196_access_crop.glb',
        'models/cacdoha_000443_access_crop.glb',
        'models/cacdoha_000116_access_crop.glb'*/
    ];
    let currentModelIndex = 0;
    let currentModel = null; // Keep a reference to the current model

    models = shuffleArray(models);
    function shuffleArray(array) {
        return array.sort(() => Math.random() - 0.5);
    }

    // Dispose materials and their textures properly
    function disposeMaterialDeep(mat) {
        if (!mat) return;
        // dispose textures inside the material
        for (const k in mat) {
            const v = mat[k];
            if (v && v.isTexture) v.dispose();
        }
        mat.dispose();
    }

    // Replace materials with shared material and dispose originals
    function replaceWithSharedMaterial(root, sharedMat) {
        root.traverse((node) => {
            if (!node.isMesh) return;
            // keep a reference to the original material(s)
            const old = node.material;
            // swap
            node.material = sharedMat;
            // dispose what the glTF created, *after* swapping
            if (Array.isArray(old)) old.forEach(disposeMaterialDeep);
            else disposeMaterialDeep(old);
        });
    }

    // Proper resource disposal function - don't dispose shared material
    function disposeModel(model) {
        if (!model) return;
        
        model.traverse((node) => {
            if (!node.isMesh) return;
            if (node.geometry) node.geometry.dispose();

            // IMPORTANT: don't dispose sharedMaterial
            const mat = node.material;
            if (Array.isArray(mat)) {
                mat.forEach(m => { if (m !== sharedMaterial) disposeMaterialDeep(m); });
            } else {
                if (mat !== sharedMaterial) disposeMaterialDeep(mat);
            }
        });
        
        scene.remove(model);
    }

    function changeModel(direction) {
        // If a sequence is playing, stop it before manual change
        if (sequence && sequence.isPlaying()) sequence.stop();
        // Properly dispose of the current model
        if (currentModel) {
            disposeModel(currentModel);
            currentModel = null;
        }

        currentModelIndex += direction;
        if (currentModelIndex < 0) currentModelIndex = models.length - 1;
        if (currentModelIndex >= models.length) currentModelIndex = 0;

        // Load the new model and keep a reference to it
        loadModel(currentModelIndex);
        
        // Request render after model change
        requestRender();
    }

    loadModel(currentModelIndex);

    // Prepare a glTF scene (no add to Three.js scene)
    function prepareGLTFScene(gltf) {
        gltf.scene.rotation.x = Math.PI;
        const zoomScale = 4.2;

        gltf.scene.traverse(function (node) {
            if (node.isMesh) {
                node.scale.set(zoomScale, zoomScale, 1);
                node.frustumCulled = true;
                
                // VR-specific geometry optimizations
                if (node.geometry) {
                    node.geometry.computeBoundingSphere();
                    node.geometry.computeBoundingBox();
                }
            }
            if (node.isPoints && node.material) {
                node.scale.set(zoomScale, zoomScale, 1);
                applyPointSettingsToRoot(node);
            }
        });

        // Replace materials with shared material and dispose originals
        replaceWithSharedMaterial(gltf.scene, sharedMaterial);
        return gltf.scene;
    }

    // Process and add immediately (used for manual model navigation)
    function handleLoadedGLTF(gltf) {
        const prepared = prepareGLTFScene(gltf);
        currentModel = prepared;
        scene.add(currentModel);
        requestRender();
    }

    function loadModel(index) {
        loader.load(models[index], function (gltf) {
            handleLoadedGLTF(gltf);
        }, undefined, function (error) {
            console.error(error);
        });
    }

    function loadGLB(url) {
        return new Promise((resolve, reject) => {
            loader.load(url, function (gltf) {
                handleLoadedGLTF(gltf);
                resolve();
            }, undefined, function (error) {
                console.error(error);
                reject(error);
            });
        });
    }

    // Load but don't add; resolve with prepared THREE.Group to swap on frame boundary
    function loadGLBPrepared(url) {
        return new Promise((resolve, reject) => {
            loader.load(url, function (gltf) {
                const prepared = prepareGLTFScene(gltf);
                resolve(prepared);
            }, undefined, function (error) {
                console.error(error);
                reject(error);
            });
        });
    }

    function disposeCurrentModel() {
        if (currentModel) {
            disposeModel(currentModel);
            currentModel = null;
        }
    }

    function getCurrentModel() { return currentModel; }

    // Queue and apply atomic swap at start of render loop to avoid VR eye flicker
    let pendingSwapScene = null;
    function queueSceneForSwap(sceneToSwapIn) {
        pendingSwapScene = sceneToSwapIn;
        requestRender();
    }

    let gamepadIndex = null;

    window.addEventListener('gamepadconnected', (event) => {
        gamepadIndex = event.gamepad.index;
        console.log(`Gamepad connected at index ${gamepadIndex}: ${event.gamepad.id}`);
    });


    window.addEventListener('gamepaddisconnected', (event) => {
        if (gamepadIndex === event.gamepad.index) {
            gamepadIndex = null;
            console.log(`Gamepad disconnected at index ${event.gamepad.index}`);
        }
    });

    window.addEventListener('keydown', (event) => {
        if (event.key === 'ArrowRight') {
            changeModel(1); // Next model
        } else if (event.key === 'ArrowLeft') {
            changeModel(-1); // Previous model
        }
    });




    function handleGamepadInput() {
        if (gamepadIndex !== null) {
            const gamepad = navigator.getGamepads()[gamepadIndex];
            if (gamepad) {
                const xAxis = gamepad.axes[2]; // Right joystick X-axis
                if (xAxis > 0.9) {
                    changeModel(1); // Next model
                } else if (xAxis < -0.9) {
                    changeModel(-1); // Previous model
                }
            }
        }
    }


    function animate() {
        renderer.setAnimationLoop(() => {
            // Apply pending swap at a safe frame boundary before rendering both eyes
            if (pendingSwapScene) {
                const previous = currentModel;
                scene.add(pendingSwapScene);
                currentModel = pendingSwapScene;
                pendingSwapScene = null;
                if (previous) {
                    scene.remove(previous);
                    // Defer heavy disposal to avoid blocking frame
                    setTimeout(() => disposeModel(previous), 0);
                }
            }
            if (renderer.xr.isPresenting) {
                user.position.set(0, -1.6, 0);
                renderer.render(scene, camera);
                return;
            }

            if (!needsRender) return;
            needsRender = false;
            
            // Only handle gamepad input occasionally, not every frame
            if (Math.random() < 0.1) { // 10% chance per frame = ~6 times per second
                handleGamepadInput();
            }
            
            // Only update camera animation if needed
            cameraZOffset += direction * 0.00005;
            if (cameraZOffset >= cameraZMaxOffset || cameraZOffset <= 0) {
                direction *= -1;
            }
            camera.position.z = -cameraZOffset;
            
            renderer.render(scene, camera);
        });
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        requestRender();
    });

    // document.getElementById('prevButton').addEventListener('click', () => {
    //   changeModel(-1); // Previous model
    // });

    document.getElementById('nextButton').addEventListener('click', () => {
        changeModel(1); // Next model
        requestRender();
    });

    // Initialize GLB sequence player (extracted to separate module)
    const sequence = initSequencePlayer({
        loadGLB,
        loadGLBPrepared,
        disposeCurrentModel,
        getCurrentModel,
        disposeModel,
        queueSceneForSwap,
        requestRender,
        buttons: { playId: 'playButton', stopId: 'stopButton', nextId: 'nextButton' },
        defaultConfig: {
            basePath: 'models/pointcloud_video_5',
            startFrame: 0,
            endFrame: 80,
            fps: 16,
            prefix: 'frame_',
            suffix: '_pointcloud.glb',
            pad: 6
        }
    });

    animate();
</script>
</body>
</html>