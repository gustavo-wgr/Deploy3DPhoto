<!DOCTYPE html>
<html lang="en">
<head>
  <title>WebXR with Three.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body { margin: 0; }
    #container { width: 100%; height: 100vh; }
    #info { position: absolute; top: 10px; left: 10px; color: white; }
  </style>
  <script type="importmap">
        {
           "imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
        }
    </script>
</head>
<body>
<div id="container"></div>


<script type="module">
  import * as THREE from 'three';
  import { VRButton } from 'three/addons/webxr/VRButton.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  const scene = new THREE.Scene();

  const data = JSON.parse('{"Height": 745, "Width": 960, "hFov": 0.9272952180016122, "vFov": 0.7412849108138079}');
  const maxFov = Math.max(data.hFov, data.vFov) * (180 / Math.PI);

  const user = new THREE.Group(); // Create user group


  const camera = new THREE.PerspectiveCamera(maxFov, data.Width / data.Height, 0.1, 1000);
  // camera.position.y = 0; // Set camera height

  user.add(camera); // Add camera to user group
  scene.add(user); // Add user group to scene

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x808080);
  renderer.xr.enabled = true;

  document.body.appendChild(VRButton.createButton(renderer));
  document.getElementById('container').appendChild(renderer.domElement);

  const loader = new GLTFLoader();
    loader.load('models/cacdoha_000140_access_crop.glb', function (gltf) {
    gltf.scene.rotation.x = Math.PI;
    gltf.scene.traverse(function (node) {
      if (node.isMesh) {
        node.material = new THREE.MeshBasicMaterial({
          vertexColors: true,
          transparent: false,
          opacity: 1.0
        });
      }
    });
    scene.add(gltf.scene);
  }, undefined, function (error) {
    console.error(error);
  });

  let cameraZOffset = 0; // Offset for camera movement
  const cameraZMaxOffset = 0.025; // Maximum offset for movement
  let direction = 1; // Direction of movement (1 for in, -1 for out)

  function animate() {
    renderer.setAnimationLoop(function () {
      if (renderer.xr.isPresenting) {
        user.position.set(0, -1.5, 0.0); // Set position for VR
      } else {
        user.position.set(0, 0, 0); // Set position for non-VR

        // Update camera Z position for oscillation
        cameraZOffset += direction * 0.00005; // Move camera slightly
        if (cameraZOffset >= cameraZMaxOffset || cameraZOffset <= 0) {
          direction *= -1; // Reverse direction
        }
        camera.position.z = -cameraZOffset; // Apply the new z position (inward movement)
      }
      renderer.render(scene, camera);
    });
  }

  animate();

  animate();
</script>