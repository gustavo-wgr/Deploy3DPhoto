<!DOCTYPE html>
<html lang="en">
<head>
  <title>Immersive Autochromes</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no">
  <style>
    body { margin: 0; overflow: hidden; }
    #container { width: 100%; height: 100vh; }
    #info { position: absolute; top: 10px; left: 10px; color: white; }
    #VRButton{z-index: 99999 !important;}
  </style>
  <script type="importmap">
        {
           "imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
        }
    </script>
</head>
<body>
<div id="container"></div>

<script type="module">
  import * as THREE from 'three';
  import { VRButton } from 'three/addons/webxr/VRButton.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  const scene = new THREE.Scene();
  const data = JSON.parse('{"Height": 745, "Width": 960, "hFov": 0.9272952180016122, "vFov": 0.7412849108138079}');
  const maxFov = 90;

  const user = new THREE.Group();
  const camera = new THREE.PerspectiveCamera(maxFov, window.innerWidth / window.innerHeight, 0.1, 100);
  user.add(camera);
  scene.add(user);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000); // Change background to black
  renderer.xr.enabled = true;

  const vrButton = VRButton.createButton(renderer);
  document.body.appendChild(vrButton);
  document.getElementById('container').appendChild(renderer.domElement);


  const loader = new GLTFLoader();
  const models = [
    'models/cacdoha_000140_access_crop.glb',
    'models/cacdoha_000122_access_crop.glb'
  ];
  let currentModelIndex = 0;

  function loadModel(index) {
    loader.load(models[index], function (gltf) {
      gltf.scene.rotation.x = Math.PI;
      const zoomScale = 4.2;

      gltf.scene.traverse(function (node) {
        if (node.isMesh) {
          node.scale.set(zoomScale, zoomScale, 1);
          node.material = new THREE.MeshBasicMaterial({
            vertexColors: true,
            transparent: true,
            // opacity: 4.0
          });
          node.frustumCulled = true;
        }
      });
      scene.add(gltf.scene);
    }, undefined, function (error) {
      console.error(error);
    });
  }

  loadModel(currentModelIndex);

  function changeModel(direction) {
    scene.clear(); // Clear the current model
    currentModelIndex += direction;
    if (currentModelIndex < 0) currentModelIndex = models.length - 1;
    if (currentModelIndex >= models.length) currentModelIndex = 0;
    loadModel(currentModelIndex);
  }

  // Listen for key presses to change models
  window.addEventListener('keydown', (event) => {
    if (event.key === 'ArrowRight') {
      changeModel(1); // Next model
    } else if (event.key === 'ArrowLeft') {
      changeModel(-1); // Previous model
    }
  });

  let cameraZOffset = 0;
  const cameraZMaxOffset = 0.025;
  let direction = 1;
  let nonVrCameraPosition = new THREE.Vector3();
  let nonVrCameraRotation = new THREE.Euler();
  let matrixCam = new THREE.Matrix4();
  nonVrCameraPosition.copy(camera.position);
  nonVrCameraRotation.copy(camera.rotation);
  matrixCam.copy(camera.matrix);

  function animate() {
    renderer.setAnimationLoop(function () {
      if (renderer.xr.isPresenting) {
        user.position.set(0, -1.6, 0);
        camera.updateProjectionMatrix();
      } else {
        camera.fov = maxFov;
        camera.position.copy(nonVrCameraRotation);
        camera.rotation.copy(nonVrCameraRotation);
        camera.matrix.copy(matrixCam);
        user.position.set(0, 0, 0);
        cameraZOffset += direction * 0.00005;
        if (cameraZOffset >= cameraZMaxOffset || cameraZOffset <= 0) {
          direction *= -1;
        }
        camera.position.z = -cameraZOffset;
      }
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    });
  }

  window.addEventListener('resize', () => {
    camera.aspect = data.Width / data.Height;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  animate();
</script>
</body>
</html>