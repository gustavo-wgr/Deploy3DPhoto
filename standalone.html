<!DOCTYPE html>
<html lang="en">
<head>
  <title>Immersive Autochromes</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no">
  <style>
    body { margin: 0; overflow: hidden; }
    #container { width: 100%; height: 100vh; }
    #info { position: absolute; top: 10px; left: 10px; color: white; }
    #VRButton{z-index: 99999 !important;}
  </style>
  <script type="importmap">
        {
           "imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
        }
    </script>
</head>
<body>
<div id="container"></div>

<script type="module">
  import * as THREE from 'three';
  import { VRButton } from 'three/addons/webxr/VRButton.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  const scene = new THREE.Scene();
  const data = JSON.parse('{"Height": 745, "Width": 960, "hFov": 0.9272952180016122, "vFov": 0.7412849108138079}');
  const maxFov = Math.max(data.hFov, data.vFov) * (180 / Math.PI) * 0.65;

  const user = new THREE.Group();
  const camera = new THREE.PerspectiveCamera(maxFov, data.Width / data.Height, 0.1, 100);

  user.add(camera);
  scene.add(user);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x808080);
  renderer.xr.enabled = true;

  const vrButton = VRButton.createButton(renderer);
  document.body.appendChild(vrButton);
  document.getElementById('container').appendChild(renderer.domElement);

  const loader = new GLTFLoader();
  loader.load('models/cacdoha_000140_access_crop.glb', function (gltf) {
    gltf.scene.rotation.x = Math.PI;
    gltf.scene.traverse(function (node) {
      if (node.isMesh) {
        node.material = new THREE.MeshBasicMaterial({
          vertexColors: true,
          transparent: false,
          opacity: 1.0
        });
        node.frustumCulled = true;
      }
    });
    scene.add(gltf.scene);
  }, undefined, function (error) {
    console.error(error);
  });

  let cameraZOffset = 0;
  const cameraZMaxOffset = 0.025;
  let direction = 1;
  let nonVrCameraPosition = new THREE.Vector3();
  let nonVrCameraRotation = new THREE.Euler();
  let matrixCam = new THREE.Matrix4();
  nonVrCameraPosition.copy(camera.position);
  nonVrCameraRotation.copy(camera.rotation);
  matrixCam.copy(camera.matrix);
  function animate() {
    renderer.setAnimationLoop(function () {
      if (renderer.xr.isPresenting) {
        // Set camera position and rotation to match non-VR
        console.log(camera);
        user.position.set(0,-1.6,-0.002650000000000002);
        user.fov = maxFov;
        camera.updateProjectionMatrix(); // Update projection matrix
      } else {
        // camera.aspect = data.Width / data.Height;
        if(camera.fov !== maxFov) {
          camera.fov = maxFov;
          camera.position.copy(nonVrCameraRotation);
          camera.rotation.copy(nonVrCameraRotation);
          camera.matrix.copy(matrixCam);
          user.position.set(0, 0, 0);
        }
        cameraZOffset += direction * 0.00005;
        if (cameraZOffset >= cameraZMaxOffset || cameraZOffset <= 0) {
          direction *= -1;
        }
        camera.position.z = -cameraZOffset;
      }
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    });
  }

  window.addEventListener('resize', () => {
    camera.aspect = data.Width / data.Height;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  animate();
</script>
</body>
</html>